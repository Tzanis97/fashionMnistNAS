# -*- coding: utf-8 -*-
"""FashionMnistModel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BOjjYMh3Jr9TRrunPKYQd5FL3rS5UCPq
"""

from tensorflow import keras
import numpy as np
import nni
from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from keras.models import Sequential
from keras.datasets import fashion_mnist
from keras.utils import to_categorical
from keras.callbacks import Callback

NUM_CLASSES = 10


def load_data():
    # χωρίζουμε τις εικόνες σε αυτές που θα χρησιμοποιηθούν για την εκπαίδευση και σε αυτές που θα χρησιμοποιηθούν για την αξιολόγηση του μοντέλου
    (x_train, y_train), (x_test, y_test) = fashion_mnist.load_data()

    # images are greyscale so the pixels goes from 0 to 255, we will normalize between 0 and 1 in order our network to train easier
    x_train = x_train.astype("float32") / 255.0
    x_test = x_test.astype("float32") / 255.0

    # για την πραξη της συνέλιξης (convolution) χρειάζεται και μια τρίτη διάσταση στις εικόνες που σηματοδοτεί το είδος τους (ασπρόμαυρες/με χρώμα)
    x_train = np.expand_dims(x_train, -1).astype("float32")
    x_test = np.expand_dims(x_test, -1).astype("float32")

    # εδω επιστρεφουμε τις ετικετες κάθε εικόνας στην αντίστοιχη από τις 10 κατηγορίες που ορίσαμε ως διάνυσμα 1x10
    # οπου το διάνυσμα θα περιέχει μηδενικά και 1 στην θέση (index) της αντίστοιχης κατηγορίας
    y_train = to_categorical(y_train, NUM_CLASSES)
    y_test = to_categorical(y_test, NUM_CLASSES)

    return (x_train, x_test), (y_train, y_test)


def build_model(params):
    # εδώ ορίζουμε το σειριακό σενάριο εκπαίδευσης του μοντέλου (pipeline)
    model = Sequential([
        Conv2D(params['filter_size_c1'], params['kernel_size_c1'], activation='relu'),
        Conv2D(params['filter_size_c2'], params['kernel_size_c2'], activation='relu'),
        MaxPooling2D(),
        Flatten(),
        Dense(params['nb_units'], activation='relu'),
        Dense(10, activation='softmax')
    ])

    # εδω προσθέτουμε έναν βελτιστοποιητή για τα βάρη του δικτύου μας με βάση έναν βαθμό βελτιστοποίησης σε κάθε βήμα
    optimizer = keras.optimizers.Adam(learning_rate=params['learning_rate'])

    # εδω ορίζουμε την συνάρτηση κόστους με βάση την οποία θα εκτιμήσουμε την απόδοση του δικτύου μας
    # Στη συγκεκριμένη περίπτωση επιλέγουμε την categorical crossentropy η οποια μας επιστρέφει ένα μέτρο (κόστος) της διαφοράς μεταξύ της εκτιμούμενης και της πραγματικής τιμής
    # κάθε εισόδου (στην πρόβλεψη της κατηγορίας στην οποία ανήκει η είσοδος). Το κόστος αυτό είναι μικρό αν επιστραφεί τιμή κοντά στο 0 και μεγάλο αν επιστραφεί τιμή κοντά στο 1
    model.compile(optimizer=optimizer, loss='categorical_crossentropy', metrics=['accuracy'])

    return model

# κλάση υπεύθυνη να αναφέρει κατά το πείραμα την ακρίβεια του μοντέλου μετά το τέλος κάθε εποχής (epoch) εκπαίδευσής του
class SendMetrics(Callback):
    def on_epoch_end(self, epoch, logs=None):
        if logs is not None:
            accuracy = logs.get('val_accuracy')
            if accuracy is not None:
                nni.report_intermediate_result(accuracy)


# ΕΚΠΑΙΔΕΥΣΗ ΤΟΥ ΜΟΝΤΕΛΟΥ
def run(params):
    # 1. Φόρτωση των δεδομένων με χρήση της αντίστοιχης συνάντησης
    (x_train, x_test), (y_train, y_test) = load_data()
    # 2. Κατασκευή του μοντέλου με κλήση της αντίστοιχης συνάρτησης
    model = build_model(params)
    # 3.Εκπαίδευση
    # Σε αυτό το στάδιο πρέπει να ορίσουμε (τα δεδομένα εκπαίδευσης, πόσες εικόνες θα επεξεργάζεται το
    # μοντέλο ταυτόχρονα, για πόσες επαναλήψεις θα εκπαιδεύσω το μοντέλο, τα δεδομένα εκτίμησης απόδοσης του μοντέλου)
    model.fit(x_train, y_train, batch_size=64, epochs=10, validation_data=(x_test, y_test), callbacks=[SendMetrics()])
    # η απώλεια (ή loss) είναι μια μετρική που αξιολογεί το πόσο καλά το μοντέλο προβλέπει τα δεδομένα δοκιμής σε σχέση με τις πραγματικές τους τιμές
    # η ακρίβεια είναι το ποσοστό των προβλέψεων που είναι σωστές σε σχέση με τις πραγματικές τιμές
    loss, acc = model.evaluate(x_test, y_test)
    # Αφού ολοκληρωθεί η εκπαίδευση, η τελική ακρίβεια αξιολογείται και αναφέρεται ως τελικό αποτέλεσμα
    nni.report_final_result(acc)
    print(acc)


if __name__ == '__main__':
    try:
        params = nni.get_next_parameters()
        run(params)
    except Exception:
        raise
